#!/usr/bin/env python3
# Copyright 2024 KU Leuven.
# Solderpad Hardware License, Version 0.51, see LICENSE for details.
# SPDX-License-Identifier: SHL-0.51

# Fanchen Kong <fanchen.kong@kuleuven.be>
import argparse
from pathlib import Path
import meminfo_lib

def meminfo():
    parser = argparse.ArgumentParser(
        description="Tools for extract the mem info for backend flow."
    )
    parser.add_argument(
        "--transcript",
        type=str,
        help="The simulation transcript with mem info."
    )
    parser.add_argument(
        "--outfile",
        "-ofile",
        type=str,
        help="Target output file."
    )
    parser.add_argument(
        "--sim_mem_info",
        action="store_true",
        help="Flag for generate the simulation mem size."
    )
    parser.add_argument(
        "--debug_sim_mem_info",
        action="store_true",
        help="Flag for generate the debug file for simulation mem size."
    )

    parsed_args = parser.parse_args()

    sim_mem_info = meminfo_lib.get_sim_mem_info(parsed_args.transcript)
    unique_sim_mem_combinations = set(sim_mem_info.values())
    ###############################
    # Get the simulation mem info #
    ###############################
    if parsed_args.sim_mem_info:
        with open(parsed_args.outfile, "w") as sim_mem_info_file:
            sim_mem_info_file.write("#Generated by meminfo.py\n")     
            sim_mem_info_file.write("#This file shows the simulation mem info from the transcript\n")
            for idx, comb in enumerate(unique_sim_mem_combinations):
                sim_mem_info_file.write(f"Sim Mem{idx:>2}: (Number of Ports: {comb[0]:>1}, Number of Word Lines: {comb[1]:>5}, Data Width: {comb[2]:>4})\n")
    if parsed_args.debug_sim_mem_info:
        with open(parsed_args.outfile, "w") as debug_sim_mem_info_file:
            debug_sim_mem_info_file.write(f"In total {len(unique_sim_mem_combinations)} simulation memory combinations\n")
            for idx, comb in enumerate(unique_sim_mem_combinations):
                debug_sim_mem_info_file.write(f"Sim Mem{idx:>2}: (Number of Ports: {comb[0]:>1}, Number of Word Lines: {comb[1]:>5}, Data Width: {comb[2]:>4})\n")
            # Create a dictionary where the key is the unique (num_ports, num_words, data_width) combination and the value is the list of instances
            comb_instance_dict = {comb: [] for comb in unique_sim_mem_combinations}
            # Populate the comb_instance_dict by checking each instance in mem_configs
            for instance, comb in sim_mem_info.items():
                comb_instance_dict[comb].append(instance)     
            debug_sim_mem_info_file.write("Detailed info:\n")
            debug_sim_mem_info_file.write("Instances for each mem combination:\n")
            for idx, (comb, instances) in enumerate(comb_instance_dict.items()):
                debug_sim_mem_info_file.write("###############################################\n")
                debug_sim_mem_info_file.write(f"Sim Mem{idx:>2}: (Number of Ports: {comb[0]:>1}, Number of Word Lines: {comb[1]:>5}, Data Width: {comb[2]:>4})\n")
                for instance in instances:
                    debug_sim_mem_info_file.write(f"  Instance: {instance}\n")
                debug_sim_mem_info_file.write("###############################################\n")
            debug_sim_mem_info_file.write("Full sim mem info histroy:\n")
            mem_info = meminfo_lib.parser_mem_info(parsed_args.transcript)
            for block in mem_info:
                block = block.strip()
                debug_sim_mem_info_file.write("###############################################\n")
                debug_sim_mem_info_file.write(block)
                debug_sim_mem_info_file.write("\n")

if __name__ == "__main__":
    meminfo()
