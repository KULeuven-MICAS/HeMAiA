// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

// This controller acts as a gatekeeper to a quadrant. It can isolate all its
// (downstream) AXI ports, gate its clock, and assert its reset through a
// register file mapped on the narrow AXI port.

// Author: Paul Scheffler <paulsc@iis.ee.ethz.ch>

// AUTOMATICALLY GENERATED by occamygen.py; edit the script instead.

module ${name}_quadrant_s1_ctrl
  import ${name}_pkg::*;
(
  input  logic clk_i,
  input  logic rst_ni,
  input  logic test_mode_i,
  input  chip_id_t chip_id_i,

  // Upward (SoC) narrow ports
  output ${soc_narrow_xbar.in_s1_quadrant_0.req_type()} soc_out_req_o,
  input  ${soc_narrow_xbar.in_s1_quadrant_0.rsp_type()} soc_out_rsp_i,
  input  ${soc_narrow_xbar.out_s1_quadrant_0.req_type()} soc_in_req_i,
  output ${soc_narrow_xbar.out_s1_quadrant_0.rsp_type()} soc_in_rsp_o,

  // Quadrant narrow ports
  output ${soc_narrow_xbar.out_s1_quadrant_0.req_type()} quadrant_out_req_o,
  input  ${soc_narrow_xbar.out_s1_quadrant_0.rsp_type()} quadrant_out_rsp_i,
  input  ${soc_narrow_xbar.in_s1_quadrant_0.req_type()} quadrant_in_req_i,
  output ${soc_narrow_xbar.in_s1_quadrant_0.rsp_type()} quadrant_in_rsp_o
);

  // Upper half of quadrant space reserved for internal use (same size as for all clusters)
  addr_t [0:0] internal_xbar_base_addr;
  assign internal_xbar_base_addr = {chip_id_i, S1QuadrantCfgBaseOffset[AddrWidth-ChipIdWidth-1:0]};

  // Quadrant Lite xbar
  // Here we have the host to cluster mailboxes
  addr_t [${num_clusters-1}:0] h2c_mailbox_base_addr;
  % for i in range(num_clusters):
  assign h2c_mailbox_base_addr[${i}] = internal_xbar_base_addr + ${i} * H2CMailboxAddressSpace;
  % endfor
  ${module}

  // Connect upward (SoC) narrow ports
  assign soc_out_req_o = ${quadrant_s1_ctrl_xbars["quad_to_soc"].out_out.req_name()};
  assign ${quadrant_s1_ctrl_xbars["quad_to_soc"].out_out.rsp_name()} = soc_out_rsp_i;
  assign ${quadrant_s1_ctrl_xbars["soc_to_quad"].in_in.req_name()} = soc_in_req_i;
  assign soc_in_rsp_o = ${quadrant_s1_ctrl_xbars["soc_to_quad"].in_in.rsp_name()};

  // Connect quadrant narrow ports
  assign quadrant_out_req_o = ${quadrant_s1_ctrl_xbars["soc_to_quad"].out_out.req_name()};
  assign ${quadrant_s1_ctrl_xbars["soc_to_quad"].out_out.rsp_name()} = quadrant_out_rsp_i;
  assign ${quadrant_s1_ctrl_xbars["quad_to_soc"].in_in.req_name()} = quadrant_in_req_i;
  assign quadrant_in_rsp_o = ${quadrant_s1_ctrl_xbars["quad_to_soc"].in_in.rsp_name()};

  // Convert both internal ports to AXI lite, since only registers for now
  <%
    quad_internal_lite = quadrant_s1_ctrl_xbars["soc_to_quad"].out_internal \
      .serialize(context, iw=1, name="soc_to_quad_internal_ser") \
      .change_dw(context, 32, "axi_to_axi_lite_dw") \
      .to_axi_lite(context, name="quad_to_soc_internal_ser", to=quadrant_s1_ctrl_mux.in_soc)
    soc_internal_lite = quadrant_s1_ctrl_xbars["quad_to_soc"].out_internal \
      .serialize(context, iw=1, name="soc_internal_serialize") \
      .change_dw(context, 32, "soc_internal_change_dw") \
      .to_axi_lite(context, name="soc_internal_to_axi_lite", to=quadrant_s1_ctrl_mux.in_quad)
  %> \

  ////////////////////////////
  //  Host2Cluster Mailbox  //
  ////////////////////////////
  % for i in range(num_clusters):
  <%
    axi_lite_h2c_mailbox_slave = quadrant_s1_ctrl_mux.__dict__[f"out_h2c_mailbox_{i}"]
  %>
  // Mailbox ${i}
  hemaia_hw_mailbox #(
    .MailboxDepth(32),
    .IrqEdgeTrig (1'b0),
    .IrqActHigh  (1'b1),
    .AxiAddrWidth(${axi_lite_h2c_mailbox_slave.aw}),
    .AxiDataWidth(${axi_lite_h2c_mailbox_slave.dw}),
    .ChipIdWidth (${chip_id_width}),
    .req_lite_t  (${axi_lite_h2c_mailbox_slave.req_type()}),
    .resp_lite_t (${axi_lite_h2c_mailbox_slave.rsp_type()})
  ) i_h2c_mailbox_${i} (
    .clk_i (${axi_lite_h2c_mailbox_slave.clk}),
    .rst_ni(${axi_lite_h2c_mailbox_slave.rst}),
    .chip_id_i(chip_id_i),
    .test_i(1'b0),
    .req_i (${axi_lite_h2c_mailbox_slave.req_name()}),
    .resp_o(${axi_lite_h2c_mailbox_slave.rsp_name()}),
    .irq_o (),
    .base_addr_i(h2c_mailbox_base_addr[${i}])
  );
  % endfor
endmodule
