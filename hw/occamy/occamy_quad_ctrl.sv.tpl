// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

// This controller acts as a gatekeeper to a quadrant. It can isolate all its
// (downstream) AXI ports, gate its clock, and assert its reset through a
// register file mapped on the narrow AXI port.

// Author: Paul Scheffler <paulsc@iis.ee.ethz.ch>

// AUTOMATICALLY GENERATED by occamygen.py; edit the script instead.

module ${name}_quad_ctrl
  import ${name}_pkg::*;
(
  input  logic     clk_i,
  input  logic     rst_ni,
  input  logic     test_mode_i,
  input  chip_id_t chip_id_i,
  // CSR Req/Rsp from cores
  // Here we assume each cluster has the same num of cores
  input  csr_req_t [NrClustersPerQuad-1:0][NrCoresPerCluster[0]-1:0] csr_req_i,
  input  logic     [NrClustersPerQuad-1:0][NrCoresPerCluster[0]-1:0] csr_req_valid_i,
  output logic     [NrClustersPerQuad-1:0][NrCoresPerCluster[0]-1:0] csr_req_ready_o,
  output csr_rsp_t [NrClustersPerQuad-1:0][NrCoresPerCluster[0]-1:0] csr_rsp_o,
  output logic     [NrClustersPerQuad-1:0][NrCoresPerCluster[0]-1:0] csr_rsp_valid_o,
  input  logic     [NrClustersPerQuad-1:0][NrCoresPerCluster[0]-1:0] csr_rsp_ready_i, 
  // Upward (SoC) narrow ports
  output ${soc_narrow_xbar.in_quad.req_type()} soc_out_req_o,
  input  ${soc_narrow_xbar.in_quad.rsp_type()} soc_out_rsp_i,
  input  ${soc_narrow_xbar.out_quad.req_type()} soc_in_req_i,
  output ${soc_narrow_xbar.out_quad.rsp_type()} soc_in_rsp_o,
  // Quadrant narrow ports
  output ${quad_ctrl_soc_to_quad_xbar.out_clusters.req_type()} quad_out_req_o,
  input  ${quad_ctrl_soc_to_quad_xbar.out_clusters.rsp_type()} quad_out_rsp_i,
  input  ${quad_ctrl_quad_to_soc_xbar.in_clusters.req_type()} quad_in_req_i,
  output ${quad_ctrl_quad_to_soc_xbar.in_clusters.rsp_type()} quad_in_rsp_o
);

  // Bingo HW Manager Signals
  logic [47:0] bingo_hw_manager_task_list_base_addr;
  logic [31:0] bingo_hw_manager_num_task;
  logic [31:0] bingo_hw_manager_start;
  logic [31:0] bingo_hw_manager_reset_start;
  logic        bingo_hw_manager_reset_start_en;


  // Quadrant Lite xbar
  // Here we have the host to cluster mailboxes
  // There is 4kB space at the beginning of the quad cfg mux
  // The rest space is reserved fro the h2c mailbox
  addr_t [${num_clusters-1}:0] h2c_mailbox_base_addr;
  % for i in range(num_clusters):
  assign h2c_mailbox_base_addr[${i}] = (QuadAXILiteNarrowBaseAddr + 4096) + ${i} * H2CMailboxAddressSpace;
  % endfor


  ${module}

  // Connect SoC narrow ports
  // Quad to SoC -> SoC Out
  assign soc_out_req_o = ${quad_ctrl_quad_to_soc_xbar.out_soc_narrow.req_name()};
  assign ${quad_ctrl_quad_to_soc_xbar.out_soc_narrow.rsp_name()} = soc_out_rsp_i;
  // SoC in -> SoC to Quad
  assign ${quad_ctrl_soc_to_quad_xbar.in_soc_narrow.req_name()} = soc_in_req_i;
  assign soc_in_rsp_o = ${quad_ctrl_soc_to_quad_xbar.in_soc_narrow.rsp_name()};

  // Connect Quad narrow ports
  // SoC to Quad -> Quad Out
  assign quad_out_req_o = ${quad_ctrl_soc_to_quad_xbar.out_clusters.req_name()};
  assign ${quad_ctrl_soc_to_quad_xbar.out_clusters.rsp_name()} = quad_out_rsp_i;
  // Quad in -> Quad to SoC
  assign ${quad_ctrl_quad_to_soc_xbar.in_clusters.req_name()} = quad_in_req_i;
  assign quad_in_rsp_o = ${quad_ctrl_quad_to_soc_xbar.in_clusters.rsp_name()};

  // SoC to Quad Xbar -> Quad axi lite narrow
  <%
    quad_ctrl_soc_to_quad_xbar.out_quad_axi_lite_narrow \
      .atomic_adapter(context, filter=True, max_trans=4, name="soc_to_quad_axi_lite_narrow_noatop") \
      .change_dw(context, 32, "soc_to_quad_to_axi_lite_narrow_dw") \
      .to_axi_lite(context, name="soc_to_quad_to_axi_lite_narrow", to=quad_ctrl_axi_lite_narrow_mux.in_soc_to_quad)
  %>
  // SoC to Quad Xbar -> Quad axi lite
  <%
    quad_ctrl_soc_to_quad_xbar.out_quad_axi_lite \
      .atomic_adapter(context, filter=True, max_trans=4, name="soc_to_quad_axi_lite_noatop") \
      .to_axi_lite(context, name="soc_to_quad_to_axi_lite", to=quad_ctrl_axi_lite_xbar.in_soc_to_quad)
  %>

  // Quad to SoC Xbar -> Quad axi lite narrow
  <%
    quad_ctrl_quad_to_soc_xbar.out_quad_axi_lite_narrow \
      .atomic_adapter(context, filter=True, max_trans=4, name="quad_to_quad_axi_lite_narrow_noatop") \
      .change_dw(context, 32, "quad_to_soc_to_quad_axi_lite_narrow_dw") \
      .to_axi_lite(context, name="quad_to_soc_to_quad_axi_lite_narrow", to=quad_ctrl_axi_lite_narrow_mux.in_quad_to_soc)
  %>
  // Quad to SoC Xbar -> Quad axi lite 
  <%
    quad_ctrl_quad_to_soc_xbar.out_quad_axi_lite\
      .atomic_adapter(context, filter=True, max_trans=4, name="quad_to_quad_axi_lite_noatop") \
      .to_axi_lite(context, name="quad_to_soc_to_quad_axi_lite", to=quad_ctrl_axi_lite_xbar.in_quad_to_soc)
  %>

  // Quad AXI Lite Xbar -> Quad to SoC Xbar
  <%
    quad_ctrl_axi_lite_xbar.out_quad_to_soc.to_axi(context, name="quad_axi_lite_to_quad_to_soc_xbar", to=quad_ctrl_quad_to_soc_xbar.in_quad_axi_lite)
  %>


  //////////////////////////////////////
  //  32bit Quad Control Periph Regs  //
  //////////////////////////////////////
  <% regbus_quad_ctrl = quad_ctrl_axi_lite_narrow_mux.out_quad_ctrl_perpheral \
    .to_reg(context, "axi_lite_to_reg_quad_ctrl_peripheral") %>
  occamy_quad_periph #(
    .reg_req_t ( ${regbus_quad_ctrl.req_type()} ),
    .reg_rsp_t ( ${regbus_quad_ctrl.rsp_type()} )
  ) i_occamy_quad_periph_regs (
    .clk_i                                  (${regbus_quad_ctrl.clk}             ),
    .rst_ni                                 (${regbus_quad_ctrl.rst}             ),
    .reg_req_i                              (${regbus_quad_ctrl.req_name()}      ),
    .reg_rsp_o                              (${regbus_quad_ctrl.rsp_name()}      ),
    .bingo_hw_manager_task_list_base_addr_o (bingo_hw_manager_task_list_base_addr),
    .bingo_hw_manager_num_task_o            (bingo_hw_manager_num_task           ),
    .bingo_hw_manager_start_o               (bingo_hw_manager_start              ),
    .bingo_hw_manager_reset_start_i         (bingo_hw_manager_reset_start        ),
    .bingo_hw_manager_reset_start_en_i      (bingo_hw_manager_reset_start_en     )
  );


  //////////////////////////////////////////////////////
  //  32bit Quad Contorl Periph Host2Cluster Mailbox  //
  //////////////////////////////////////////////////////
  % for i in range(num_clusters):
  <%
    axi_lite_h2c_mailbox_slave = quad_ctrl_axi_lite_narrow_mux.__dict__[f"out_h2c_mailbox_{i}"]
  %>
  // Mailbox ${i}
  hemaia_hw_mailbox #(
    .MailboxDepth(16),
    .IrqEdgeTrig (1'b0),
    .IrqActHigh  (1'b1),
    .AxiAddrWidth(${axi_lite_h2c_mailbox_slave.aw}),
    .AxiDataWidth(${axi_lite_h2c_mailbox_slave.dw}),
    .ChipIdWidth (${chip_id_width}),
    .req_lite_t  (${axi_lite_h2c_mailbox_slave.req_type()}),
    .resp_lite_t (${axi_lite_h2c_mailbox_slave.rsp_type()})
  ) i_h2c_mailbox_${i} (
    .clk_i (${axi_lite_h2c_mailbox_slave.clk}),
    .rst_ni(${axi_lite_h2c_mailbox_slave.rst}),
    .chip_id_i(chip_id_i),
    .test_i(1'b0),
    .req_i (${axi_lite_h2c_mailbox_slave.req_name()}),
    .resp_o(${axi_lite_h2c_mailbox_slave.rsp_name()}),
    .irq_o (),
    .base_addr_i(h2c_mailbox_base_addr[${i}])
  );
  % endfor

  ////////////////////////////////////////////////////
  //  64bit Quad AXI Lite Periph: Bingo HW Manager  //
  ////////////////////////////////////////////////////
  // ADDR Space for the axi lite periph
  localparam addr_t CHIPLET_DONE_QUEUE_BASE    = QuadAXILiteBaseAddr + 0 * 4096;
  localparam addr_t HOST_READY_DONE_QUEUE_BASE = QuadAXILiteBaseAddr + 1 * 4096;
  // We will use the CSR interface for the cores to read ready queue and write done queue
  // CSR Signals for the bingo hw manager
  // The +1 here is due to the host will also act as a core in cluster
  // For the TO case each cluster has two cores: gemm(core0) and dma(core1)
  // The host will be the core2 at cluster 0
  localparam int unsigned BINGO_HW_MANAGER_NR_CORE_PER_CLUSTER = NrCoresPerCluster[0] + 1;
  csr_req_t [BINGO_HW_MANAGER_NR_CORE_PER_CLUSTER-1:0][NrClustersPerQuad-1:0] bingo_hw_manager_csr_req;
  logic     [BINGO_HW_MANAGER_NR_CORE_PER_CLUSTER-1:0][NrClustersPerQuad-1:0] bingo_hw_manager_csr_req_valid;
  logic     [BINGO_HW_MANAGER_NR_CORE_PER_CLUSTER-1:0][NrClustersPerQuad-1:0] bingo_hw_manager_csr_req_ready;
  csr_rsp_t [BINGO_HW_MANAGER_NR_CORE_PER_CLUSTER-1:0][NrClustersPerQuad-1:0] bingo_hw_manager_csr_rsp;
  logic     [BINGO_HW_MANAGER_NR_CORE_PER_CLUSTER-1:0][NrClustersPerQuad-1:0] bingo_hw_manager_csr_rsp_valid;
  logic     [BINGO_HW_MANAGER_NR_CORE_PER_CLUSTER-1:0][NrClustersPerQuad-1:0] bingo_hw_manager_csr_rsp_ready;
  bingo_hw_manager_top #(
    .READY_AND_DONE_QUEUE_INTERFACE_TYPE(1), // 1: CSR 0: AXI LITE
    .TASK_QUEUE_TYPE                    (1), // 1: AXI Lite Master 0: Default AXI Lite Slave 
    .NUM_CORES_PER_CLUSTER    (BINGO_HW_MANAGER_NR_CORE_PER_CLUSTER    ),
    .NUM_CLUSTERS_PER_CHIPLET (NrClustersPerQuad       ),
    .HostAxiLiteAddrWidth     (${quad_ctrl_axi_lite_xbar.aw}             ),
    .HostAxiLiteDataWidth     (${quad_ctrl_axi_lite_xbar.dw}             ),
    .DeviceAxiLiteAddrWidth   (${quad_ctrl_axi_lite_narrow_mux.aw}       ),
    .DeviceAxiLiteDataWidth   (${quad_ctrl_axi_lite_narrow_mux.dw}       ),
    .host_axi_lite_req_t      (${quad_ctrl_axi_lite_xbar.out_bingo_hw_scheduler_chiplet_done_queue.req_type()}     ),
    .host_axi_lite_resp_t     (${quad_ctrl_axi_lite_xbar.out_bingo_hw_scheduler_chiplet_done_queue.rsp_type()}     ),
    .device_axi_lite_req_t    (${quad_ctrl_axi_lite_narrow_mux.out_quad_ctrl_perpheral.req_type()}              ),
    .device_axi_lite_resp_t   (${quad_ctrl_axi_lite_narrow_mux.out_quad_ctrl_perpheral.rsp_type()}               ),
    .csr_req_t                (csr_req_t                ),
    .csr_rsp_t                (csr_rsp_t                )
  ) i_bingo_hw_manager (
    .clk_i                              (clk_i                        ),
    .rst_ni                             (rst_ni                       ),
    .chip_id_i                          (chip_id_i                    ),
    // Since we set TASK_QUEUE_TYPE = 1
    // Not use the task queue slave
    .task_queue_base_addr_i             ('0                           ),
    .task_queue_axi_lite_req_i          ('0                           ),
    .task_queue_axi_lite_resp_o         (/* not used */               ),
    // We use the task queue master port 
    .task_list_base_addr_i              (bingo_hw_manager_task_list_base_addr       ),
    .num_task_i                         (bingo_hw_manager_num_task                  ),
    .bingo_hw_manager_start_i           (bingo_hw_manager_start                     ),
    .bingo_hw_manager_reset_start_o     (bingo_hw_manager_reset_start               ),
    .bingo_hw_manager_reset_start_en_o  (bingo_hw_manager_reset_start_en            ),
    .task_queue_axi_lite_req_o          (${quad_ctrl_axi_lite_xbar.in_bingo_hw_scheduler_read_local_task.req_name()}),
    .task_queue_axi_lite_resp_i         (${quad_ctrl_axi_lite_xbar.in_bingo_hw_scheduler_read_local_task.rsp_name()}),
    .chiplet_mailbox_base_addr_i        (CHIPLET_DONE_QUEUE_BASE                    ),
    .to_remote_chiplet_axi_lite_req_o   (${quad_ctrl_axi_lite_xbar.in_bingo_hw_scheduler_write_remote_done.req_name()}),
    .to_remote_chiplet_axi_lite_resp_i  (${quad_ctrl_axi_lite_xbar.in_bingo_hw_scheduler_write_remote_done.rsp_name()}),
    .from_remote_axi_lite_req_i         (${quad_ctrl_axi_lite_xbar.out_bingo_hw_scheduler_chiplet_done_queue.req_name()}),
    .from_remote_axi_lite_resp_o        (${quad_ctrl_axi_lite_xbar.out_bingo_hw_scheduler_chiplet_done_queue.rsp_name()}),
    // Since we set READY_AND_DONE_QUEUE_INTERFACE_TYPE=1
    // We do not use the axi lite slave for ready and done queue
    .done_queue_base_addr_i             ('0                           ),
    .done_queue_axi_lite_req_i          ('0                           ),
    .done_queue_axi_lite_resp_o         (/* not used */               ),
    .ready_queue_base_addr_i            ('0                           ),
    .ready_queue_axi_lite_req_i         ('0                           ),
    .ready_queue_axi_lite_resp_o        (/* not used */               ),
    .csr_req_i                          (bingo_hw_manager_csr_req                     ),
    .csr_req_valid_i                    (bingo_hw_manager_csr_req_valid               ),
    .csr_req_ready_o                    (bingo_hw_manager_csr_req_ready               ),
    .csr_rsp_o                          (bingo_hw_manager_csr_rsp                     ),
    .csr_rsp_valid_o                    (bingo_hw_manager_csr_rsp_valid               ),
    .csr_rsp_ready_i                    (bingo_hw_manager_csr_rsp_ready               )
  );

  // We need an extra work here to connect the host master port to the csr
  csr_req_t host_ready_done_csr_req;
  logic host_ready_done_csr_req_valid;
  logic host_ready_done_csr_req_ready;
  csr_rsp_t host_ready_done_csr_rsp;
  logic host_ready_done_csr_rsp_valid;
  logic host_ready_done_csr_rsp_ready;
  axi_lite_to_csr #(
    .AXI_LITE_ADDR_WIDTH(${quad_ctrl_axi_lite_xbar.aw}),
    .AXI_LITE_DATA_WIDTH(${quad_ctrl_axi_lite_xbar.dw}),
    .axi_lite_req_t(${quad_ctrl_axi_lite_xbar.out_bingo_hw_scheduler_host_ready_done_intf.req_type()}),
    .axi_lite_rsp_t(${quad_ctrl_axi_lite_xbar.out_bingo_hw_scheduler_host_ready_done_intf.rsp_type()}),
    .csr_req_t(csr_req_t),
    .csr_rsp_t(csr_rsp_t)
  ) i_host_ready_done_axi_lite_to_csr (
    .clk_i(${quad_ctrl_axi_lite_xbar.clk}),
    .rst_ni(${quad_ctrl_axi_lite_xbar.rst}),
    .axi_lite_req_i(${quad_ctrl_axi_lite_xbar.out_bingo_hw_scheduler_host_ready_done_intf.req_name()}),
    .axi_lite_rsp_o(${quad_ctrl_axi_lite_xbar.out_bingo_hw_scheduler_host_ready_done_intf.rsp_name()}),
    .csr_req_o      (host_ready_done_csr_req),
    .csr_req_valid_o(host_ready_done_csr_req_valid),
    .csr_req_ready_i(host_ready_done_csr_req_ready),
    .csr_rsp_i      (host_ready_done_csr_rsp),
    .csr_rsp_valid_i(host_ready_done_csr_rsp_valid),
    .csr_rsp_ready_o(host_ready_done_csr_rsp_ready)
  );
  %for cluster in range(num_clusters):
    %for core in range(num_cores_per_cluster):
    // Connect Normal Core${core} Cluster${cluster}
  assign bingo_hw_manager_csr_req[${core}][${cluster}] = csr_req_i[${cluster}][${core}];
  assign bingo_hw_manager_csr_req_valid[${core}][${cluster}] = csr_req_valid_i[${cluster}][${core}];
  assign csr_req_ready_o[${cluster}][${core}] = bingo_hw_manager_csr_req_ready[${core}][${cluster}];
  assign csr_rsp_o[${cluster}][${core}] = bingo_hw_manager_csr_rsp[${core}][${cluster}];
  assign csr_rsp_valid_o[${cluster}][${core}] = bingo_hw_manager_csr_rsp_valid[${core}][${cluster}];
  assign bingo_hw_manager_csr_rsp_ready[${core}][${cluster}] = csr_rsp_ready_i[${cluster}][${core}];
    %endfor
  %endfor

  // Special treat to host simd core
  %for cluster in range(num_clusters):
      %if cluster == 0:
  // Connect the host to cluster 0 ports
  assign bingo_hw_manager_csr_req[${num_cores_per_cluster}][${cluster}] = host_ready_done_csr_req;
  assign bingo_hw_manager_csr_req_valid[${num_cores_per_cluster}][${cluster}] = host_ready_done_csr_req_valid;
  assign host_ready_done_csr_req_ready = bingo_hw_manager_csr_req_ready[${num_cores_per_cluster}][${cluster}];
  assign host_ready_done_csr_rsp = bingo_hw_manager_csr_rsp[${num_cores_per_cluster}][${cluster}];
  assign host_ready_done_csr_rsp_valid = bingo_hw_manager_csr_rsp_valid[${num_cores_per_cluster}][${cluster}];
  assign bingo_hw_manager_csr_rsp_ready[${num_cores_per_cluster}][${cluster}] = host_ready_done_csr_rsp_ready;
      %else:
  // Tie off Cluster ${cluster} unused ports
  assign bingo_hw_manager_csr_req[${num_cores_per_cluster}][${cluster}] = '0;
  assign bingo_hw_manager_csr_req_valid[${num_cores_per_cluster}][${cluster}] = '0;
  assign bingo_hw_manager_csr_rsp_ready[${num_cores_per_cluster}][${cluster}] = '0;
      %endif
  %endfor
endmodule
