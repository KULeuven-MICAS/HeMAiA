// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

// Author: Nils Wistoff <nwistoff@iis.ee.ethz.ch>
//
// AUTOMATICALLY GENERATED by genoccamy.py; edit the script instead.

module ${name}_chip
import ${name}_pkg::*;
 (
  input  logic        clk_i,
  input  logic        rst_ni,
  /// Peripheral clock
  input  logic        clk_periph_i,
  input  logic        rst_periph_ni,
  /// Real-time clock (for time keeping)
  input  logic        rtc_i,
  input  logic        test_mode_i,
  input  chip_id_t    chip_id_i,
  input  logic [1:0]  boot_mode_i,
% if occamy_cfg['hemaia_multichip']['single_chip'] is False: 
  // Currently the router is implemented, so bidirectional connections toward E/S/W/N is needed, with 578b payload
    // East side
    input  logic     east_test_being_requested_i,
    output logic     east_test_request_o,
    output logic     flow_control_east_rts_o,
    input  logic     flow_control_east_cts_i,
    input  logic     flow_control_east_rts_i,
    output logic     flow_control_east_cts_o,
    inout  logic    [19:0] east_d2d_io [3],
    // West side
    // West side
    input  logic     west_test_being_requested_i,
    output logic     west_test_request_o,
    output logic     flow_control_west_rts_o,
    input  logic     flow_control_west_cts_i,
    input  logic     flow_control_west_rts_i,
    output logic     flow_control_west_cts_o,
    inout  logic    [19:0] west_d2d_io [3],
    // North side
    input  logic     north_test_being_requested_i,
    output logic     north_test_request_o,
    output logic     flow_control_north_rts_o,
    input  logic     flow_control_north_cts_i,
    input  logic     flow_control_north_rts_i,
    output logic     flow_control_north_cts_o,
    inout  logic    [19:0] north_d2d_io [3],
    // South side
    input  logic     south_test_being_requested_i,
    output logic     south_test_request_o,
    output logic     flow_control_south_rts_o,
    input  logic     flow_control_south_cts_i,
    input  logic     flow_control_south_rts_i,
    output logic     flow_control_south_cts_o,
    inout  logic    [19:0] south_d2d_io [3],
% endif
  // `uart` Interface
  output logic        uart_tx_o,
  input  logic        uart_rx_i,
  output logic        uart_rts_no, 
  input  logic        uart_cts_ni, 
  // `gpio` Interface
  input  logic [31:0] gpio_d_i,
  output logic [31:0] gpio_d_o,
  output logic [31:0] gpio_oe_o,
<% 
  spi_slave_present = any(periph["name"] == "spis" for periph in occamy_cfg["peripherals"]["axi_lite_peripherals"])
%>
% if spi_slave_present: 
  // `SPI Slave` for Debugging Purposes
  input  logic        spis_sck_i,
  input  logic        spis_csb_i,
  output logic [3:0]  spis_sd_o,
  output logic [3:0]  spis_sd_en_o,
  input  logic [3:0]  spis_sd_i,
% endif
  // `jtag` Interface
  input  logic        jtag_trst_ni,
  input  logic        jtag_tck_i,
  input  logic        jtag_tms_i,
  input  logic        jtag_tdi_i,
  output logic        jtag_tdo_o
);

  ///////////////////
  // Chip ID Latch //
  ///////////////////

  // The latched chip_id
  chip_id_t chip_id;

  always_latch begin
    if (~rst_ni) begin
      chip_id <= chip_id_i;
    end
  end

  //////////////////////////////
  // SRAM L2 Memory Subsystem //
  //////////////////////////////

  <%
    axi_soc_to_mem = soc_wide_xbar.out_hemaia_mem.copy(name="axi_soc_to_mem").declare(context)
    axi_mem_to_soc = soc_wide_xbar.in_hemaia_mem.copy(name="axi_mem_to_soc").declare(context)
  %> \
  hemaia_mem_system #(
    .chip_id_t (chip_id_t),
    .axi_master_req_t (${axi_soc_to_mem.req_type()}),
    .axi_master_rsp_t (${axi_soc_to_mem.rsp_type()}),
    .axi_slave_req_t (${axi_mem_to_soc.req_type()}),
    .axi_slave_rsp_t (${axi_mem_to_soc.rsp_type()}),
    .MemBaseAddr (${occamy_cfg['spm_wide']["address"]}),
    .MemBankNum (${occamy_cfg['spm_wide']["banks"]}),
    .MemSize (${occamy_cfg['spm_wide']["length"]})
  ) i_hemaia_mem_system (
    .clk_i,
    .rst_ni,
    .chip_id_i        (chip_id),
    .axi_master_req_i (${axi_soc_to_mem.req_name()}),
    .axi_master_rsp_o (${axi_soc_to_mem.rsp_name()}),
    .axi_slave_req_o  (${axi_mem_to_soc.req_name()}),
    .axi_slave_rsp_i  (${axi_mem_to_soc.rsp_name()})
  );

  ///////////////////
  //   Boot ROM    //
  ///////////////////

  ${soc_axi_lite_narrow_periph_xbar.out_bootrom.req_type()} bootrom_axi_lite_req;
  ${soc_axi_lite_narrow_periph_xbar.out_bootrom.rsp_type()} bootrom_axi_lite_rsp;

  <% regbus_bootrom = soc_axi_lite_narrow_periph_xbar.out_bootrom.to_reg(context, "bootrom", fr="bootrom_axi_lite") %>

  bootrom i_bootrom (
    .clk_i(clk_i), 
    .rst_ni(rst_ni), 
    .req_i(bootrom_req.valid), 
    .addr_i(bootrom_req.addr[31:0]), 
    .data_o(bootrom_rsp.rdata)
  );

  assign bootrom_rsp.ready   = '1;
  assign bootrom_rsp.error   = '0;

  ///////////////////
  //  Occamy Top   //
  ///////////////////
  % if occamy_cfg['hemaia_multichip']['single_chip'] is False: 
  // Control bus
  ${soc_axi_lite_narrow_periph_xbar.out_hemaia_d2d_link.req_type()} hemaia_d2d_link_ctrl_req;
  ${soc_axi_lite_narrow_periph_xbar.out_hemaia_d2d_link.rsp_type()} hemaia_d2d_link_ctrl_rsp;
  // Data bus
  // AXI HeMAiA SoC -> HeMAiA D2D
  ${soc2router_bus.req_type()} soc2router_req;
  ${soc2router_bus.rsp_type()} soc2router_rsp;
  // AXI HeMAiA SoC -> HeMAiA D2D
  ${router2soc_bus.req_type()} router2soc_req;
  ${router2soc_bus.rsp_type()} router2soc_rsp;
  % endif


  ${name}_top i_${name} (
    .clk_i              (clk_i),
    .rst_ni             (rst_ni),
    .sram_cfgs_i        ('0),
    .clk_periph_i       (clk_periph_i),
    .rst_periph_ni      (rst_periph_ni),
    .rtc_i              (rtc_i),
    .test_mode_i        (test_mode_i),
    .chip_id_i          (chip_id),
% if occamy_cfg['hemaia_multichip']['single_chip'] is False: 
    // Control registers
    .hemaia_d2d_link_ctrl_req_o   (hemaia_d2d_link_ctrl_req),
    .hemaia_d2d_link_ctrl_rsp_i   (hemaia_d2d_link_ctrl_rsp),
    // Chiplet Requst to Router
    .soc2router_req_o   (soc2router_req),
    .soc2router_rsp_i   (soc2router_rsp),
    // Router Requst to Chiplet
    .router2soc_req_i   (router2soc_req),
    .router2soc_rsp_o   (router2soc_rsp),
% endif
    .boot_mode_i        (boot_mode_i),
    .uart_tx_o          (uart_tx_o),
    .uart_cts_ni        (uart_cts_ni),
    .uart_rts_no        (uart_rts_no),
    .uart_rx_i          (uart_rx_i),
    .gpio_d_i           (gpio_d_i),
    .gpio_d_o           (gpio_d_o),
    .gpio_oe_o          (gpio_oe_o),
    .jtag_trst_ni       (jtag_trst_ni),
    .jtag_tck_i         (jtag_tck_i),
    .jtag_tms_i         (jtag_tms_i),
    .jtag_tdi_i         (jtag_tdi_i),
    .jtag_tdo_o         (jtag_tdo_o),
    .i2c_sda_o          (),
    .i2c_sda_i          ('1),
    .i2c_sda_en_o       (),
    .i2c_scl_o          (),
    .i2c_scl_i          ('1),
    .i2c_scl_en_o       (),
    .spim_sck_o         (),
    .spim_sck_en_o      (),
    .spim_csb_o         (),
    .spim_csb_en_o      (),
    .spim_sd_o          (),
    .spim_sd_en_o       (),
    .spim_sd_i          ('1),
% if spi_slave_present: 
    .spis_sck_i         (spis_sck_i),
    .spis_csb_i         (spis_csb_i),
    .spis_sd_o          (spis_sd_o),
    .spis_sd_en_o       (spis_sd_en_o),
    .spis_sd_i          (spis_sd_i),
% endif    
    .bootrom_req_o      (bootrom_axi_lite_req),
    .bootrom_rsp_i      (bootrom_axi_lite_rsp),
    .hemaia_mem_axi_req_o(${axi_soc_to_mem.req_name()}),
    .hemaia_mem_axi_rsp_i(${axi_soc_to_mem.rsp_name()}),
    .hemaia_mem_axi_req_i(${axi_mem_to_soc.req_name()}),
    .hemaia_mem_axi_rsp_o(${axi_mem_to_soc.rsp_name()}),
    .chip_ctrl_req_o    (),
    .chip_ctrl_rsp_i    ('0),
    .ext_irq_i          ('0)
  );


% if occamy_cfg['hemaia_multichip']['single_chip'] is False:
  //////////////////////
  //  HeMAiA D2D Link //
  //////////////////////

  hemaia_d2d_link #(
    .chip_id_t (chip_id_t),
    .axi_req_t (${soc2router_bus.req_type()}),
    .axi_rsp_t (${soc2router_bus.rsp_type()}),
    .axi_lite_req_t (${soc_axi_lite_narrow_periph_xbar.out_hemaia_d2d_link.req_type()}),
    .axi_lite_rsp_t (${soc_axi_lite_narrow_periph_xbar.out_hemaia_d2d_link.rsp_type()}),
    .aw_chan_t (${soc2router_bus.aw_chan_type()}),
    .ar_chan_t (${soc2router_bus.ar_chan_type()}),
    .r_chan_t (${soc2router_bus.r_chan_type()}),
    .w_chan_t (${soc2router_bus.w_chan_type()}),
    .b_chan_t (${soc2router_bus.b_chan_type()})
  ) i_d2d_link (
    .chip_id_i(chip_id),

    .control_clk_i(clk_periph_i),
    .control_rst_ni(rst_periph_ni),
    .digital_clk_i(clk_i),
    .digital_rst_ni(rst_ni),
    .analog_clk_i(clk_i),
    .analog_rst_ni(rst_ni),

    .axi_lite_req_i(hemaia_d2d_link_ctrl_req),
    .axi_lite_rsp_o(hemaia_d2d_link_ctrl_rsp),

    .axi_in_req_i(soc2router_req),
    .axi_in_rsp_o(soc2router_rsp),
    .axi_out_req_o(router2soc_req),
    .axi_out_rsp_i(router2soc_rsp),

    .east_test_being_requested_i,
    .east_test_request_o,
    .flow_control_east_rts_o,
    .flow_control_east_cts_i,
    .flow_control_east_rts_i,
    .flow_control_east_cts_o,
    .east_phy_io(east_d2d_io),

    .west_test_being_requested_i,
    .west_test_request_o,
    .flow_control_west_rts_o,
    .flow_control_west_cts_i,
    .flow_control_west_rts_i,
    .flow_control_west_cts_o,
    .west_phy_io(west_d2d_io),

    .north_test_being_requested_i,
    .north_test_request_o,
    .flow_control_north_rts_o,
    .flow_control_north_cts_i,
    .flow_control_north_rts_i,
    .flow_control_north_cts_o,
    .north_phy_io(north_d2d_io),

    .south_test_being_requested_i,
    .south_test_request_o,
    .flow_control_south_rts_o,
    .flow_control_south_cts_i,
    .flow_control_south_rts_i,
    .flow_control_south_cts_o,
    .south_phy_io(south_d2d_io),

  );

% endif

endmodule
