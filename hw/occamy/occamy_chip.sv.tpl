// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

// Author: Nils Wistoff <nwistoff@iis.ee.ethz.ch>
//
// AUTOMATICALLY GENERATED by genoccamy.py; edit the script instead.

module ${name}_chip
import ${name}_pkg::*;
 (
  // The Clock Reset Controller takes care of clk_i and rst_ni, should not be marked as false_path
  input  logic        clk_i,
  input  logic        rst_ni,
  // clk_periph_i and rst_periph_ni are directly used by logics, should be marked as false_path
  input  logic        clk_periph_i,
  (* false_path *) input  logic        rst_periph_ni,
  // Quasi-static configuration signals, can be marked as false_path
  (* false_path *) input  logic        test_mode_i,
  (* false_path *) input  chip_id_t    chip_id_i,
  (* false_path *) input  logic [1:0]  boot_mode_i,
% if occamy_cfg['hemaia_multichip']['single_chip'] is False: 
  // East side
  input  logic        east_test_being_requested_i,
  output logic        east_test_request_o,
  output logic        flow_control_east_rts_o,
  input  logic        flow_control_east_cts_i,
  input  logic        flow_control_east_rts_i,
  output logic        flow_control_east_cts_o,
  inout  logic [19:0] east_d2d_io [3],
  // West side
  input  logic        west_test_being_requested_i,
  output logic        west_test_request_o,
  output logic        flow_control_west_rts_o,
  input  logic        flow_control_west_cts_i,
  input  logic        flow_control_west_rts_i,
  output logic        flow_control_west_cts_o,
  inout  logic [19:0] west_d2d_io [3],
  // North side
  input  logic        north_test_being_requested_i,
  output logic        north_test_request_o,
  output logic        flow_control_north_rts_o,
  input  logic        flow_control_north_cts_i,
  input  logic        flow_control_north_rts_i,
  output logic        flow_control_north_cts_o,
  inout  logic [19:0] north_d2d_io [3],
  // South side
  input  logic        south_test_being_requested_i,
  output logic        south_test_request_o,
  output logic        flow_control_south_rts_o,
  input  logic        flow_control_south_cts_i,
  input  logic        flow_control_south_rts_i,
  output logic        flow_control_south_cts_o,
  inout  logic [19:0] south_d2d_io [3],
% endif
  // `uart` Interface
  output logic        uart_tx_o,
  input  logic        uart_rx_i,
  output logic        uart_rts_no, 
  input  logic        uart_cts_ni, 
  // `gpio` Interface
  input  logic [31:0] gpio_d_i,
  output logic [31:0] gpio_d_o,
  output logic [31:0] gpio_oe_o,
<% 
  spi_slave_present = any(periph["name"] == "spis" for periph in occamy_cfg["peripherals"]["axi_lite_peripherals"])
%>
% if spi_slave_present: 
  // `SPI Slave` for Debugging Purposes
  input  logic        spis_sck_i,
  input  logic        spis_csb_i,
  output logic [3:0]  spis_sd_o,
  output logic [3:0]  spis_sd_en_o,
  input  logic [3:0]  spis_sd_i,

% endif
  // SPI Master Interface
  output logic        spim_sck_o,
  output logic        spim_sck_en_o,
  output logic [1:0]  spim_csb_o,
  output logic [1:0]  spim_csb_en_o,
  output logic [3:0]  spim_sd_o,
  output logic [3:0]  spim_sd_en_o,
  input  logic [3:0]  spim_sd_i,

  // `jtag` Interface
  input  logic        jtag_trst_ni,
  input  logic        jtag_tck_i,
  input  logic        jtag_tms_i,
  input  logic        jtag_tdi_i,
  output logic        jtag_tdo_o,

  // I2C Interface
  output logic        i2c_sda_o,
  input  logic        i2c_sda_i,
  output logic        i2c_sda_en_o,
  output logic        i2c_scl_o,
  input  logic        i2c_scl_i,
  output logic        i2c_scl_en_o
);

  ///////////////////
  // Chip ID Latch //
  ///////////////////

  // The latched chip_id
  (* false_path *) chip_id_t chip_id;

  always_latch begin
    if (~rst_ni) begin
      chip_id <= chip_id_i;
    end
  end

  ///////////////////////////////////
  //  HeMAiA Clock & Reset Manager //
  ///////////////////////////////////

<%
  num_d2d_clk_domain = 0
  if occamy_cfg["hemaia_multichip"]["single_chip"] is False:
    num_d2d_clk_domain = 4
  num_acc_clk_domain = len(occamy_cfg["clusters"])
%>
  // Control Clock / clk_periph_i: Peripheral Slow Speed Clock
  // Master Clock / clk_i: Oscillator Clock
  // Clock Channel 0 / clk_o[0]: Host Clock
  // Clock Channel 1 / clk_o[1]: Accelerator Cluster Clock
  // Clock Channel 2 / clk_o[2]: East D2D TX Clock
  // Clock Channel 3 / clk_o[3]: West D2D TX Clock
  // Clock Channel 4 / clk_o[4]: North D2D TX Clock
  // Clock Channel 5 / clk_o[5]: South D2D TX Clock

  // Control Clock: 100 MHz
  // Master Clock: 3.2GHz
  // Clock Channel 0: 3.2GHz / 6 = 533MHz
  // Clock Channel 1: 3.2GHz / 6 = 533MHz
  // Clock Channel 2: 3.2GHz / 1 = 3.2GHz
  // Clock Channel 3: 3.2GHz / 1 = 3.2GHz
  // Clock Channel 4: 3.2GHz / 1 = 3.2GHz
  // Clock Channel 5: 3.2GHz / 1 = 3.2GHz
  
  ${soc_axi_lite_narrow_periph_xbar.out_hemaia_clk_rst_controller.req_type()} hemaia_clk_rst_controller_req;
  ${soc_axi_lite_narrow_periph_xbar.out_hemaia_clk_rst_controller.rsp_type()} hemaia_clk_rst_controller_rsp;


  localparam int HeMAiADefaultDivision[${1+num_acc_clk_domain+num_d2d_clk_domain}] = '{
    6
  % for _ in range(num_acc_clk_domain):
    ,6
  % endfor
  % if occamy_cfg["hemaia_multichip"]["single_chip"] is False:
    ,1,1,1,1
  % endif
  };
  localparam int ResetDelays[${1+num_acc_clk_domain+num_d2d_clk_domain}] = '{default: 3};

  logic [${1+num_acc_clk_domain+num_d2d_clk_domain-1}:0] clk_vec, rst_n_vec;
  (* syn_keep = 1, syn_preserve = 1 *)
  logic clk_host;
% if occamy_cfg["hemaia_multichip"]["single_chip"] is False: 
  (* syn_keep = 1, syn_preserve = 1 *)
  logic
      clk_d2d_phy_east,
      clk_d2d_phy_west,
      clk_d2d_phy_north,
      clk_d2d_phy_south;
% endif
  (* syn_keep = 1, syn_preserve = 1 *)
  logic [${num_acc_clk_domain-1}:0] clk_acc;

  (* syn_keep = 1, syn_preserve = 1 *)
  logic rst_host_n;
% if occamy_cfg["hemaia_multichip"]["single_chip"] is False: 
  (* syn_keep = 1, syn_preserve = 1 *)
  logic
      rst_d2d_phy_east_n,
      rst_d2d_phy_west_n,
      rst_d2d_phy_north_n,
      rst_d2d_phy_south_n;
% endif
  (* syn_keep = 1, syn_preserve = 1 *)
  logic [${num_acc_clk_domain-1}:0] rst_acc_n;

  assign clk_host = clk_vec[0];
  assign clk_acc = clk_vec[1 +: ${num_acc_clk_domain}];
% if occamy_cfg["hemaia_multichip"]["single_chip"] is False:
  assign clk_d2d_phy_east = clk_vec[${1+num_acc_clk_domain}];
  assign clk_d2d_phy_west = clk_vec[${2+num_acc_clk_domain}];
  assign clk_d2d_phy_north = clk_vec[${3+num_acc_clk_domain}];
  assign clk_d2d_phy_south = clk_vec[${4+num_acc_clk_domain}];
% endif

  assign rst_host_n = rst_n_vec[0];
  assign rst_acc_n = rst_n_vec[1 +: ${num_acc_clk_domain}];
% if occamy_cfg["hemaia_multichip"]["single_chip"] is False:
  assign rst_d2d_phy_east_n = rst_n_vec[${1+num_acc_clk_domain}];
  assign rst_d2d_phy_west_n = rst_n_vec[${2+num_acc_clk_domain}];
  assign rst_d2d_phy_north_n = rst_n_vec[${3+num_acc_clk_domain}];
  assign rst_d2d_phy_south_n = rst_n_vec[${4+num_acc_clk_domain}];
% endif

  hemaia_clk_rst_controller #(
    .NumClocks(${1+num_acc_clk_domain+num_d2d_clk_domain}),
    .MaxDivisionWidth(8),
    .DefaultDivision(HeMAiADefaultDivision),
    .ResetDelays(ResetDelays),
    .axi_lite_req_t (${soc_axi_lite_narrow_periph_xbar.out_hemaia_clk_rst_controller.req_type()}),
    .axi_lite_rsp_t (${soc_axi_lite_narrow_periph_xbar.out_hemaia_clk_rst_controller.rsp_type()})
  ) i_hemaia_clk_rst_controller (
    .test_mode_i(test_mode_i),
    .control_clk_i(clk_periph_i),
    .control_rst_ni(rst_periph_ni),
    .axi_lite_req_i(hemaia_clk_rst_controller_req),
    .axi_lite_rsp_o(hemaia_clk_rst_controller_rsp),
    .mst_clk_i(clk_i),
    .mst_rst_ni(rst_ni),
    .clk_o(clk_vec),
    .rst_no(rst_n_vec)
  );

  //////////////////////////////
  // SRAM L2 Memory Subsystem //
  //////////////////////////////

  <%
    axi_wide_soc_to_mem = soc_wide_xbar.out_hemaia_mem.copy(name="axi_wide_soc_to_mem").declare(context)
    axi_wide_mem_to_soc = soc_wide_xbar.in_hemaia_mem.copy(name="axi_wide_mem_to_soc").declare(context)
    axi_narrow_soc_to_mem = soc_narrow_xbar.out_hemaia_mem.copy(name="axi_narrow_soc_to_mem").declare(context)
    axi_narrow_mem_to_soc = soc_narrow_xbar.in_hemaia_mem.copy(name="axi_narrow_mem_to_soc").declare(context)
  %> \
  hemaia_mem_system #(
    .chip_id_t (chip_id_t),
    .axi_wide_master_req_t (${axi_wide_soc_to_mem.req_type()}),
    .axi_wide_master_rsp_t (${axi_wide_soc_to_mem.rsp_type()}),
    .axi_wide_slave_req_t (${axi_wide_mem_to_soc.req_type()}),
    .axi_wide_slave_rsp_t (${axi_wide_mem_to_soc.rsp_type()}),
    .axi_narrow_master_req_t (${axi_narrow_soc_to_mem.req_type()}),
    .axi_narrow_master_rsp_t (${axi_narrow_soc_to_mem.rsp_type()}),
    .axi_narrow_slave_req_t (${axi_narrow_mem_to_soc.req_type()}),
    .axi_narrow_slave_rsp_t (${axi_narrow_mem_to_soc.rsp_type()}),
    .ClusterAddressSpace (${cluster_address_space}),
    .MemBaseAddr (${occamy_cfg['spm_wide']["address"]}),
    .MemBankNum (${occamy_cfg['spm_wide']["banks"]}),
    .MemSize (${occamy_cfg['spm_wide']["length"]})
  ) i_hemaia_mem_system (
    .clk_i            (clk_host),
    .rst_ni           (rst_host_n),
    .chip_id_i        (chip_id),
    .axi_wide_master_req_i (${axi_wide_soc_to_mem.req_name()}),
    .axi_wide_master_rsp_o (${axi_wide_soc_to_mem.rsp_name()}),
    .axi_wide_slave_req_o  (${axi_wide_mem_to_soc.req_name()}),
    .axi_wide_slave_rsp_i  (${axi_wide_mem_to_soc.rsp_name()}),
    .axi_narrow_master_req_i (${axi_narrow_soc_to_mem.req_name()}),
    .axi_narrow_master_rsp_o (${axi_narrow_soc_to_mem.rsp_name()}),
    .axi_narrow_slave_req_o  (${axi_narrow_mem_to_soc.req_name()}),
    .axi_narrow_slave_rsp_i  (${axi_narrow_mem_to_soc.rsp_name()})
  );

  ///////////////////
  //   Boot ROM    //
  ///////////////////

  ${soc_axi_lite_narrow_periph_xbar.out_bootrom.req_type()} bootrom_axi_lite_req;
  ${soc_axi_lite_narrow_periph_xbar.out_bootrom.rsp_type()} bootrom_axi_lite_rsp;

  <% regbus_bootrom = soc_axi_lite_narrow_periph_xbar.out_bootrom.to_reg(context, "bootrom", fr="bootrom_axi_lite") %>

  bootrom i_bootrom (
    .clk_i(clk_periph_i), 
    .rst_ni(rst_periph_ni), 
    .req_i(bootrom_req.valid), 
    .addr_i(bootrom_req.addr[31:0]), 
    .data_o(bootrom_rsp.rdata)
  );

  assign bootrom_rsp.ready   = '1;
  assign bootrom_rsp.error   = '0;

  ///////////////////
  //  Occamy Top   //
  ///////////////////
  % if occamy_cfg['hemaia_multichip']['single_chip'] is False: 
  // HeMAiA D2D Control bus
  ${soc_axi_lite_narrow_periph_xbar.out_hemaia_d2d_link.req_type()} hemaia_d2d_link_ctrl_req;
  ${soc_axi_lite_narrow_periph_xbar.out_hemaia_d2d_link.rsp_type()} hemaia_d2d_link_ctrl_rsp;
  // Data bus
  // AXI HeMAiA SoC -> HeMAiA D2D
  ${soc2router_bus.req_type()} soc2router_req;
  ${soc2router_bus.rsp_type()} soc2router_rsp;
  // AXI HeMAiA SoC -> HeMAiA D2D
  ${router2soc_bus.req_type()} router2soc_req;
  ${router2soc_bus.rsp_type()} router2soc_rsp;
  % endif

  ${name}_top i_${name} (
    .clk_i              (clk_host),
    .rst_ni             (rst_host_n),
    .clk_acc_i          (clk_acc),
    .rst_acc_ni         (rst_acc_n),
    .sram_cfgs_i        ('0),
    .clk_periph_i       (clk_periph_i),
    .rst_periph_ni      (rst_periph_ni),
    .rtc_i              ('0),
    .test_mode_i        (test_mode_i),
    .chip_id_i          (chip_id),
% if occamy_cfg['hemaia_multichip']['single_chip'] is False: 
    // Control registers
    .hemaia_d2d_link_ctrl_req_o   (hemaia_d2d_link_ctrl_req),
    .hemaia_d2d_link_ctrl_rsp_i   (hemaia_d2d_link_ctrl_rsp),
    // Chiplet Requst to Router
    .soc2router_req_o   (soc2router_req),
    .soc2router_rsp_i   (soc2router_rsp),
    // Router Requst to Chiplet
    .router2soc_req_i   (router2soc_req),
    .router2soc_rsp_o   (router2soc_rsp),
% endif
    .boot_mode_i        (boot_mode_i),
    .uart_tx_o          (uart_tx_o),
    .uart_cts_ni        (uart_cts_ni),
    .uart_rts_no        (uart_rts_no),
    .uart_rx_i          (uart_rx_i),
    .gpio_d_i           (gpio_d_i),
    .gpio_d_o           (gpio_d_o),
    .gpio_oe_o          (gpio_oe_o),
    .jtag_trst_ni       (jtag_trst_ni),
    .jtag_tck_i         (jtag_tck_i),
    .jtag_tms_i         (jtag_tms_i),
    .jtag_tdi_i         (jtag_tdi_i),
    .jtag_tdo_o         (jtag_tdo_o),
    .i2c_sda_o          (i2c_sda_o),
    .i2c_sda_i          (i2c_sda_i),
    .i2c_sda_en_o       (i2c_sda_en_o),
    .i2c_scl_o          (i2c_scl_o),
    .i2c_scl_i          (i2c_scl_i),
    .i2c_scl_en_o       (i2c_scl_en_o),
    .spim_sck_o         (spim_sck_o),
    .spim_sck_en_o      (spim_sck_en_o),
    .spim_csb_o         (spim_csb_o),
    .spim_csb_en_o      (spim_csb_en_o),
    .spim_sd_o          (spim_sd_o),
    .spim_sd_en_o       (spim_sd_en_o),
    .spim_sd_i          (spim_sd_i),
% if spi_slave_present: 
    .spis_sck_i         (spis_sck_i),
    .spis_csb_i         (spis_csb_i),
    .spis_sd_o          (spis_sd_o),
    .spis_sd_en_o       (spis_sd_en_o),
    .spis_sd_i          (spis_sd_i),
% endif    
    .bootrom_req_o      (bootrom_axi_lite_req),
    .bootrom_rsp_i      (bootrom_axi_lite_rsp),
    // HeMAiA Mem system wide
    .hemaia_mem_axi_wide_req_o(${axi_wide_soc_to_mem.req_name()}),
    .hemaia_mem_axi_wide_rsp_i(${axi_wide_soc_to_mem.rsp_name()}),
    .hemaia_mem_axi_wide_req_i(${axi_wide_mem_to_soc.req_name()}),
    .hemaia_mem_axi_wide_rsp_o(${axi_wide_mem_to_soc.rsp_name()}),
    // HeMAiA Mem system narrow
    .hemaia_mem_axi_narrow_req_o(${axi_narrow_soc_to_mem.req_name()}),
    .hemaia_mem_axi_narrow_rsp_i(${axi_narrow_soc_to_mem.rsp_name()}),
    .hemaia_mem_axi_narrow_req_i(${axi_narrow_mem_to_soc.req_name()}),
    .hemaia_mem_axi_narrow_rsp_o(${axi_narrow_mem_to_soc.rsp_name()}),

    // HeMAiA Reset & Clock Controller
    .hemaia_clk_rst_controller_req_o(hemaia_clk_rst_controller_req),
    .hemaia_clk_rst_controller_rsp_i(hemaia_clk_rst_controller_rsp),

    .ext_irq_i          ('0)
  );

% if occamy_cfg['hemaia_multichip']['single_chip'] is False:
  //////////////////////
  //  HeMAiA D2D Link //
  //////////////////////

  hemaia_d2d_link #(
    .chip_id_t (chip_id_t),
    .axi_req_t (${soc2router_bus.req_type()}),
    .axi_rsp_t (${soc2router_bus.rsp_type()}),
    .axi_lite_req_t (${soc_axi_lite_narrow_periph_xbar.out_hemaia_d2d_link.req_type()}),
    .axi_lite_rsp_t (${soc_axi_lite_narrow_periph_xbar.out_hemaia_d2d_link.rsp_type()}),
    .aw_chan_t (${soc2router_bus.aw_chan_type()}),
    .ar_chan_t (${soc2router_bus.ar_chan_type()}),
    .r_chan_t (${soc2router_bus.r_chan_type()}),
    .w_chan_t (${soc2router_bus.w_chan_type()}),
    .b_chan_t (${soc2router_bus.b_chan_type()})
  ) i_d2d_link (
    .chip_id_i(chip_id),

    .control_clk_i(clk_periph_i),
    .control_rst_ni(rst_periph_ni),
    .digital_clk_i(clk_host),
    .east_phy_tx_clk_i(clk_d2d_phy_east),
    .west_phy_tx_clk_i(clk_d2d_phy_west),
    .north_phy_tx_clk_i(clk_d2d_phy_north),
    .south_phy_tx_clk_i(clk_d2d_phy_south),
    .rst_ni(rst_ni),

    .axi_lite_req_i(hemaia_d2d_link_ctrl_req),
    .axi_lite_rsp_o(hemaia_d2d_link_ctrl_rsp),

    .axi_in_req_i(soc2router_req),
    .axi_in_rsp_o(soc2router_rsp),
    .axi_out_req_o(router2soc_req),
    .axi_out_rsp_i(router2soc_rsp),

    .east_test_being_requested_i,
    .east_test_request_o,
    .flow_control_east_rts_o,
    .flow_control_east_cts_i,
    .flow_control_east_rts_i,
    .flow_control_east_cts_o,
    .east_phy_io(east_d2d_io),

    .west_test_being_requested_i,
    .west_test_request_o,
    .flow_control_west_rts_o,
    .flow_control_west_cts_i,
    .flow_control_west_rts_i,
    .flow_control_west_cts_o,
    .west_phy_io(west_d2d_io),

    .north_test_being_requested_i,
    .north_test_request_o,
    .flow_control_north_rts_o,
    .flow_control_north_cts_i,
    .flow_control_north_rts_i,
    .flow_control_north_cts_o,
    .north_phy_io(north_d2d_io),

    .south_test_being_requested_i,
    .south_test_request_o,
    .flow_control_south_rts_o,
    .flow_control_south_cts_i,
    .flow_control_south_rts_i,
    .flow_control_south_cts_o,
    .south_phy_io(south_d2d_io)
  );

% endif

endmodule
