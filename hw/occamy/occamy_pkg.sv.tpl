// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
// Florian Zaruba <zarubaf@iis.ee.ethz.ch>
//
// AUTOMATICALLY GENERATED by occamygen.py; edit the script instead.
// verilog_lint: waive-start line-length

`include "axi/typedef.svh"
`include "register_interface/typedef.svh"
`include "apb/typedef.svh"

package ${name}_pkg;
  localparam int unsigned MaxTransaction = 16;

  // Re-exports
  localparam int unsigned AddrWidth = ${addr_width};
  localparam int unsigned NarrowUserWidth = ${narrow_user_width};
  localparam int unsigned WideUserWidth = ${wide_user_width};

  localparam int unsigned NrClustersS1Quadrant = ${nr_clusters_s1_quadrant};
  localparam int unsigned NrCoresCluster [NrClustersS1Quadrant] = '${core_per_cluster};
  localparam int unsigned NrCoresClusterOffset [NrClustersS1Quadrant] = '${nr_cores_cluster_offset};
  localparam int unsigned NrCoresS1Quadrant = ${nr_cores_quadrant};

  // Memory cut configurations: one per memory parameterization
  // SRAM configurations
  typedef struct packed {
% for field, width in sram_cfg_fields.items():
    logic [${width-1}:0] ${field};
% endfor
  } sram_cfg_t;

  typedef struct packed {
    sram_cfg_t icache_tag;
    sram_cfg_t icache_data;
    sram_cfg_t tcdm;
  } cluster_sram_cfgs_t;

  typedef struct packed {
    sram_cfg_t rocache_tag;
    sram_cfg_t rocache_data;
    cluster_sram_cfgs_t cluster;
  } sram_cfg_quadrant_t;

  typedef struct packed {
    sram_cfg_t dcache_valid_dirty;
    sram_cfg_t dcache_tag;
    sram_cfg_t dcache_data;
    sram_cfg_t icache_tag;
    sram_cfg_t icache_data;
  } sram_cfg_cva6_t;

  typedef struct packed {
    sram_cfg_t spm_narrow;
    sram_cfg_t spm_wide;
    sram_cfg_cva6_t cva6;
    sram_cfg_quadrant_t quadrant;
  } sram_cfgs_t;

  localparam int unsigned SramCfgWidth = $bits(sram_cfg_t);
  localparam int unsigned SramCfgCount = $bits(sram_cfgs_t)/SramCfgWidth;

  typedef struct packed {
    logic [3:0] timer;
    logic [31:0] gpio;
    logic uart;
    logic spim_error;
    logic spim_spi_event;
    logic i2c_fmt_watermark;
    logic i2c_rx_watermark;
    logic i2c_fmt_overflow;
    logic i2c_rx_overflow;
    logic i2c_nak;
    logic i2c_scl_interference;
    logic i2c_sda_interference;
    logic i2c_stretch_timeout;
    logic i2c_sda_unstable;
    logic i2c_trans_complete;
    logic i2c_tx_empty;
    logic i2c_tx_nonempty;
    logic i2c_tx_overflow;
    logic i2c_acq_overflow;
    logic i2c_ack_stop;
    logic i2c_host_timeout;
    logic ecc_narrow_uncorrectable;
    logic ecc_narrow_correctable;
    logic ecc_wide_uncorrectable;
    logic ecc_wide_correctable;
    // 4 programmable, 8 HBM (1x per channel)
    logic [12:0] ext_irq;
    logic zero;
  } ${name}_interrupt_t;

  localparam logic [15:0] PartNum = 2;
  localparam logic [31:0] IDCode = (dm::DbgVersion013 << 28) | (PartNum << 12) | 32'h1;


  localparam int unsigned ChipIdWidth = ${hemaia_multichip["chip_id_width"]};
  typedef logic [ChipIdWidth-1:0] chip_id_t;

  typedef logic [AddrWidth-1:0] addr_t;
  typedef logic [NarrowUserWidth-1:0] user_narrow_t;
  typedef logic [WideUserWidth-1:0] user_wide_t;

  typedef struct packed {
    logic [31:0] idx;
    logic [47:0] start_addr;
    logic [47:0] end_addr;
  } xbar_rule_48_t;


  typedef xbar_rule_48_t xbar_rule_t;

  /// We reserve hartid `0` for CVA6.
  localparam logic [9:0] HartIdOffset = 1;
  /// The base offset for each cluster.
  localparam addr_t ClusterBaseOffset = ${cluster_base_addr};
  /// The address space set aside for each slave.
  localparam addr_t ClusterAddressSpace = ${cluster_base_offset};
  /// The address space of a single S1 quadrant.
  localparam addr_t S1QuadrantAddressSpace = ClusterAddressSpace * NrClustersS1Quadrant;
  /// The base offset of the quadrant configuration region.
  localparam addr_t S1QuadrantCfgBaseOffset = ${quad_cfg_base_addr};
  /// The address space set aside for the configuration of each slave.
  localparam addr_t S1QuadrantCfgAddressSpace = ${quad_cfg_base_offset};


  ${package}

endpackage
// verilog_lint: waive-off line-length
